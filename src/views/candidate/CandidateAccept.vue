<script setup>
import { ref, watchEffect } from 'vue';
import axios from '@axios';
import DialogCloseBtn from '@core/components/DialogCloseBtn.vue';
import { computed } from 'vue';
import { toast } from 'vue3-toastify';
import { watch } from 'vue';

const props = defineProps({
  id: {
    type: [String, Number], // –£–∫–∞–∑—ã–≤–∞–µ–º –¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö
    required: true, // –î–µ–ª–∞–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º
  },
});

const emit = defineEmits(['fetchDatas']);

const isDialogVisible = ref(false);
const isFetching = ref(false);
const comment = ref();
const selectedCompany = ref();
const selectedVacancy = ref();

const onFormCancel = () => {
  comment.value = '';
  isDialogVisible.value = false;
};

const onSubmit = async () => {
  isFetching.value = true;
  try {
    await axios.post(`/candidates/${props.id}/update_state/accept`, {
      vacancy_id: selectedVacancy.value,
      company_id: selectedCompany.value,
      comment: comment.value,
    });

    toast('–£—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ', {
      theme: 'auto',
      type: 'success',
      dangerouslyHTMLString: true,
    });
    emit('fetchDatas');
    onFormCancel();
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ :', error);
  } finally {
    isFetching.value = false;
  }
};

const companies_list = ref([]);

const fetchCompanies = async () => {
  try {
    const response = await axios.get('/companies');
    companies_list.value = await response.data.companies;
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ :', error);
  }
};
watchEffect(fetchCompanies);

const vacancies_list = ref([]);

const fetchVacancies = async () => {
  try {
    const response = await axios.get(`/vacancies?company_id=${selectedCompany.value}`);
    const vacancies = await response.data?.vacancies;
    if (vacancies.length) {
      selectedVacancy.value = null;
      vacancies_list.value = vacancies?.map((el) => ({
        id: el.id,
        job_position_name_ru: el.job_position.name_ru,
      }));
    } else {
      selectedVacancy.value = 0;
      vacancies_list.value = [
        {
          id: 0,
          job_position_name_ru: 'no vacancies found in this company',
        },
      ];
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ :', error);
  }
};
watch(selectedCompany, (newVal) => {
  if (newVal) fetchVacancies();
});

const isFetching1 = ref(false);
const isFetching2 = ref(false);
const isFetching3 = ref(false);

const onCancel = async () => {
  isFetching1.value = true;
  try {
    await axios.post(`/candidates/${props.id}/update_state/cancel`, {
      comment: comment.value,
    });

    toast('–£—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ', {
      theme: 'auto',
      type: 'success',
      dangerouslyHTMLString: true,
    });
    emit('fetchDatas');
    comment.value = '';
    isDialogVisible.value = false;
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ :', error);
  } finally {
    isFetching1.value = false;
  }
};

const onBlock = async () => {
  isFetching2.value = true;
  try {
    await axios.post(`/candidates/${props.id}/update_state/block`, {
      comment: comment.value,
    });

    toast('–£—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ', {
      theme: 'auto',
      type: 'success',
      dangerouslyHTMLString: true,
    });
    emit('fetchDatas');
    comment.value = '';
    isDialogVisible.value = false;
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ :', error);
  } finally {
    isFetching2.value = false;
  }
};

const onArchive = async () => {
  isFetching3.value = true;
  try {
    let url = `/candidates/${props.id}/update_state/`;
    if (props.state_slug === 'archive') url = url + 'un_archive';
    else url = url + 'archive';
    await axios.post(url, { comment: comment.value });

    toast('–£—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ', {
      theme: 'auto',
      type: 'success',
      dangerouslyHTMLString: true,
    });
    emit('fetchDatas');
    comment.value = '';
    isDialogVisible.value = false;
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ :', error);
  } finally {
    isFetching3.value = false;
  }
};
</script>

<template>
  <VDialog v-model="isDialogVisible" max-width="600">
    <!-- Dialog Activator -->
    <template #activator="{ props }">
      <VIcon
        v-bind="props"
        @click="
          (event) => {
            event.stopPropagation();
          }
        "
        size="30"
        icon="bx-check"
      ></VIcon>
    </template>

    <!-- Dialog Content -->
    <VCard title="User Profile">
      <DialogCloseBtn variant="text" size="small" @click="onFormCancel" />

      <VCardText>
        <VRow class="justify-center">
          <VCol cols="12">
            <VTextarea label="Comment" v-model="comment" />
          </VCol>
          <VCol cols="6">
            <VSelect
              v-model="selectedCompany"
              label="Select Company"
              :items="companies_list"
              item-title="title"
              item-value="id"
              clearable
              clear-icon="bx-x"
            />
          </VCol>
          <VCol cols="6">
            <VSelect
              v-if="vacancies_list.length"
              v-model="selectedVacancy"
              label="Select Vacancy"
              :items="vacancies_list"
              item-title="job_position_name_ru"
              item-value="id"
              clearable
              clear-icon="bx-x"
              aria-selected="true"
            />
          </VCol>

          <!-- üëâ Submit and Cancel -->

          <VCol cols="3" class="px-1">
            <VBtn
              :loading="isFetching1"
              :disabled="isFetching1 || isFetching2 || isFetching3"
              class="w-100"
              @click="onCancel"
            >
              Bekor qilish
              <VIcon icon="bx-minus-circle" class="ml-1 mr-0" />
            </VBtn>
          </VCol>
          <VCol cols="3" class="px-1">
            <VBtn
              :loading="isFetching2"
              :disabled="isFetching1 || isFetching2 || isFetching3"
              class="w-100"
              color="error"
              @click="onBlock"
            >
              Bloklash
              <VIcon icon="bx-block" class="ml-1 mr-0" />
            </VBtn>
          </VCol>
          <VCol cols="3" class="px-1">
            <VBtn
              :loading="isFetching3"
              :disabled="isFetching1 || isFetching2 || isFetching3"
              class="w-100"
              color="secondary"
              @click="onArchive"
            >
              Archive
              <VIcon icon="bx-archive-in" class="ml-1 mr-0" />
            </VBtn>
          </VCol>
          <VCol cols="3" class="px-1">
            <VBtn @click="onSubmit" :loading="isFetching" :disabled="isFetching" class="w-100">
              Submit
              <VIcon icon="mdi-file-document-arrow-right-outline" class="ml-1 mr-0" />
            </VBtn>
          </VCol>
        </VRow>
      </VCardText>

      <!-- <VCardText class="d-flex justify-end gap-2">
        <VBtn color="secondary" variant="tonal" @click="isDialogVisible = false"> Close </VBtn>
        <VBtn @click="isDialogVisible = false"> Save </VBtn>
      </VCardText> -->
    </VCard>
  </VDialog>
</template>
